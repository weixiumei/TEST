{"remainingRequest":"/Users/weixiumei/Documents/TEST/webpack_demo/node_modules/babel-loader/lib/index.js!/Users/weixiumei/Documents/TEST/webpack_demo/src/index.js","dependencies":[{"path":"/Users/weixiumei/Documents/TEST/webpack_demo/src/index.js","mtime":1547984025000},{"path":"/Users/weixiumei/Documents/TEST/webpack_demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weixiumei/Documents/TEST/webpack_demo/node_modules/babel-loader/lib/index.js","mtime":1530808242000}],"contextDependencies":[],"result":["import _ from 'lodash';\nimport './style.css';\n\nfunction component() {\n  let element = document.createElement('div');\n\n  // Lodash, currently included via a script, is required for this line to work\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n}\n\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst getRegExp = re => {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nconst isType = (obj, type) => {\n  if (typeof obj !== 'object') return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case 'Array':\n      flag = typeString === '[object Array]';\n      break;\n    case 'Date':\n      flag = typeString === '[object Date]';\n      break;\n    case 'RegExp':\n      flag = typeString === '[object RegExp]';\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n\nconst clone = parent => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n  const _clone = parent => {\n    console.log('parent', parent);\n    if (parent === null) return null;\n    if (typeof parent !== 'object') {\n      return parent;\n    }\n    let child, proto;\n    if (isType(parent, 'Array')) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, 'RegExp')) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, 'Date')) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      // = parent.__proto__\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链，相当于浅拷贝\n      child = Object.create(proto);\n      console.log('proto-child', proto, child);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n    console.log('index', index, parent);\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n\n    parents.push(parent);\n    children.push(child);\n    console.log('parents', parents);\n    console.log('children', children);\n    console.log('#####################');\n    for (let i in parent) {\n      // 递归\n      console.log('####递归', i, parent[i]);\n      child[i] = _clone(parent[i]);\n    }\n    console.log(child);\n    return child;\n  };\n  return _clone(parent);\n};\n\nfunction Father() {}\nFather.prototype.name = 'wei';\n\nfunction Son() {}\n// 继承\nSon.prototype = new Father();\nSon.prototype.say = function () {\n  console.log('hi');\n};\nSon.prototype.say1 = function () {\n  console.log('hi');\n};\nSon.prototype.ok = {\n  aa: 11,\n  bb: 11\n  // Son.prototype.ok = null\n  // Son.prototype.un = undefined\n  // Son.prototype.array_num = {\n  //   aaa:[1,2]\n  // }\n};var aa = new Son();\n// clone(aa)\n\n//################\nvar oldObj = {\n  a: 1,\n  a1: { a: 1 },\n  bb: ['wei', 'xiu'],\n  cc: function () {\n    alert('11');\n  }\n  // var newObj1 = oldObj\n  // 1.他无法实现对函数 、RegExp等特殊对象的克隆\n  // 2.会抛弃对象的constructor,所有的构造函数会指向Object\n  // 3.对象有循环引用,会报错\n  // var newObj2 = JSON.parse(JSON.stringify(oldObj))\n  // var newObj3 = clone(oldObj)\n  // console.log(newObj1)\n  // console.log(newObj2)\n  // console.log(newObj3)\n  // console.log('-------------')\n  // oldObj.aa = 2\n  // console.log(newObj1)\n  // console.log(newObj2)\n  // console.log(newObj3)\n\n  //################\n\n};var func = new function () {\n  this.a = \"func\";\n}();\nvar myfunc = function (x) {\n  var a = \"myfunc\";\n  console.log(this.a);\n  console.log(x);\n};\n// myfunc.call(func,\"var\");    //弹出func和var\n\n//################\n\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n  this.showName = function () {\n    console.log(this.name + ' age is ' + age);\n  };\n}\nfunction Cat(name, age) {\n  //call必须是object\n  Animal.call(this, name, age);\n}\nCat.prototype = new Animal();\nfunction Dog(name, age) {\n  //apply必须是array, 可以直接将当前函数的arguments对象作为apply的第二个参数传进去\n  // Animal.apply(this, arguments);\n  Animal.apply(this, [name, age]);\n}\nDog.prototype = new Animal();\nvar cat = new Cat(\"Black Cat\", 12);\nvar dog = new Dog(\"Black Dog\", 13);\n// cat.showName();  //Black Cat age is 12\n// dog.showName();  //Black Dog age is 13\n\n//################\n\nvar foo = function () {\n  // 是不污染全局对象，变量一直存在\n  var secret = 'secret';\n  // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的\n  return {\n    get_secret: function () {\n      // 通过定义的接口来访问 secret\n      return secret;\n    },\n    new_secret: function (new_secret) {\n      // 通过定义的接口来修改 secret\n      secret = new_secret;\n    }\n  };\n}();\n\nfoo.get_secret(); // 得到 'secret'\nfoo.secret; // Type error，访问不能\nfoo.new_secret('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量\nfoo.get_secret(); // 得到 'a new secret'\n\n//################\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  var c = i;\n  a[i] = function () {\n    console.log(c);\n  };\n}\na[6](); // 9\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  let c = i;\n  a[i] = function () {\n    console.log(c);\n  };\n}\na[6](); // 6",{"version":3,"sources":["src/index.js"],"names":["_","component","element","document","createElement","innerHTML","join","getRegExp","re","flags","global","ignoreCase","multiline","isType","obj","type","typeString","Object","prototype","toString","call","flag","clone","parent","parents","children","_clone","console","log","child","proto","RegExp","source","lastIndex","Date","getTime","getPrototypeOf","create","index","indexOf","push","i","Father","name","Son","say","say1","ok","aa","bb","oldObj","a","a1","cc","alert","func","myfunc","x","Animal","age","showName","Cat","Dog","apply","cat","dog","foo","secret","get_secret","new_secret","c"],"mappings":"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","file":"index.js","sourceRoot":"/Users/weixiumei/Documents/TEST/webpack_demo","sourcesContent":["import _ from 'lodash';\nimport './style.css';\n\nfunction component() {\n  let element = document.createElement('div');\n\n  // Lodash, currently included via a script, is required for this line to work\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n}\n\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst getRegExp = re => {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nconst isType = (obj, type) => {\n  if (typeof obj !== 'object') return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case 'Array':\n      flag = typeString === '[object Array]';\n      break;\n    case 'Date':\n      flag = typeString === '[object Date]';\n      break;\n    case 'RegExp':\n      flag = typeString === '[object RegExp]';\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n\nconst clone = parent => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n  const _clone = parent => {\n    console.log('parent', parent)\n    if (parent === null) return null;\n    if (typeof parent !== 'object') {\n      return parent;\n    }\n    let child, proto;\n    if (isType(parent, 'Array')) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, 'RegExp')) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, 'Date')) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      // = parent.__proto__\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链，相当于浅拷贝\n      child = Object.create(proto);\n      console.log('proto-child', proto, child)\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n    console.log('index', index, parent)\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n\n    parents.push(parent);\n    children.push(child);\n    console.log('parents',parents)\n    console.log('children',children)\n    console.log('#####################')\n    for (let i in parent) {\n      // 递归\n      console.log('####递归',i, parent[i])\n      child[i] = _clone(parent[i]);\n    }\n    console.log(child)\n    return child;\n  };\n  return _clone(parent);\n};\n\nfunction Father(){\n}\nFather.prototype.name = 'wei'\n\nfunction Son(){\n}\n// 继承\nSon.prototype = new Father()\nSon.prototype.say = function(){\n  console.log('hi');\n}\nSon.prototype.say1 = function(){\n  console.log('hi');\n}\nSon.prototype.ok = {\n  aa:11,\n  bb:11\n}\n// Son.prototype.ok = null\n// Son.prototype.un = undefined\n// Son.prototype.array_num = {\n//   aaa:[1,2]\n// }\nvar aa = new Son()\n// clone(aa)\n\n//################\nvar oldObj = {\n  a:1,\n  a1:{a:1},\n  bb:['wei','xiu'],\n  cc:function(){\n    alert('11')\n  }\n}\n// var newObj1 = oldObj\n// 1.他无法实现对函数 、RegExp等特殊对象的克隆\n// 2.会抛弃对象的constructor,所有的构造函数会指向Object\n// 3.对象有循环引用,会报错\n// var newObj2 = JSON.parse(JSON.stringify(oldObj))\n// var newObj3 = clone(oldObj)\n// console.log(newObj1)\n// console.log(newObj2)\n// console.log(newObj3)\n// console.log('-------------')\n// oldObj.aa = 2\n// console.log(newObj1)\n// console.log(newObj2)\n// console.log(newObj3)\n\n//################\n\nvar func=new function(){\n  this.a=\"func\"\n}\nvar myfunc=function(x){\n  var a=\"myfunc\";\n  console.log(this.a);\n  console.log(x);\n}\n// myfunc.call(func,\"var\");    //弹出func和var\n\n//################\n\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n  this.showName = function() {\n    console.log(this.name+' age is '+age);\n  };\n}\nfunction Cat(name, age) {\n  //call必须是object\n  Animal.call(this, name, age);\n}\nCat.prototype = new Animal();\nfunction Dog(name, age) {\n  //apply必须是array, 可以直接将当前函数的arguments对象作为apply的第二个参数传进去\n  // Animal.apply(this, arguments);\n  Animal.apply(this, [name, age]);\n}\nDog.prototype = new Animal();\nvar cat = new Cat(\"Black Cat\",12); \nvar dog = new Dog(\"Black Dog\", 13); \n// cat.showName();  //Black Cat age is 12\n// dog.showName();  //Black Dog age is 13\n\n//################\n\nvar foo = ( function() {\n  // 是不污染全局对象，变量一直存在\n  var secret = 'secret';\n  // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的\n  return {\n    get_secret: function () {\n      // 通过定义的接口来访问 secret\n      return secret;\n    },\n    new_secret: function ( new_secret ) {\n      // 通过定义的接口来修改 secret\n      secret = new_secret;\n    }\n  };\n} () );\n\nfoo.get_secret (); // 得到 'secret'\nfoo.secret; // Type error，访问不能\nfoo.new_secret ('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量\nfoo.get_secret (); // 得到 'a new secret'\n\n//################\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  var c = i;\n  a[i] = function () {\n    console.log(c);\n  };\n}\na[6](); // 9\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  let c = i;\n  a[i] = function () {\n    console.log(c);\n  };\n}\na[6](); // 6"]}]}